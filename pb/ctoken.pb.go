// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ctoken.proto

package API_Presidio

import (
	context "context"
	fmt "fmt"
	math "math"

	proto "github.com/gogo/protobuf/proto"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type CTokenResponseErrorCodes int32

const (
	CTokenResponse_NO_ERROR       CTokenResponseErrorCodes = 0
	CTokenResponse_INTERNAL_ERROR CTokenResponseErrorCodes = 1
)

var CTokenResponseErrorCodes_name = map[int32]string{
	0: "NO_ERROR",
	1: "INTERNAL_ERROR",
}

var CTokenResponseErrorCodes_value = map[string]int32{
	"NO_ERROR":       0,
	"INTERNAL_ERROR": 1,
}

func (x CTokenResponseErrorCodes) String() string {
	return proto.EnumName(CTokenResponseErrorCodes_name, int32(x))
}

func (CTokenResponseErrorCodes) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_70252b6cac540031, []int{2, 0}
}

//*
// The request to the cToken API can specify a number filters, such
// as which tokens to retrieve information about or moment in time.
// The following shows an example set of request
// parameters in JSON:
// <code>{
//   "addresses": [] // returns all tokens if empty or not included
//   "block_timestamp": 0 // returns latest information if given 0
// }</code>
type CTokenRequest struct {
	// List of token addresses to filter on, e.g.: ["0x...", ,"0x..."] [Optional]
	Addresses [][]byte `protobuf:"bytes,1,rep,name=addresses,proto3" json:"addresses,omitempty"`
	// Only one of block_number or block timestamp should be provided. If provided, API returns data for given block number from our historical data. Otherwise, API defaults to returning the latest information. [Optional]
	BlockNumber uint32 `protobuf:"varint,2,opt,name=block_number,json=blockNumber,proto3" json:"block_number,omitempty"`
	// Only one of block_number or block timestamp should be provided. If provided, API returns data for given block timestamp from our historical data. Otherwise, API defaults to returning the latest information. [Optional]
	BlockTimestamp       uint32   `protobuf:"varint,3,opt,name=block_timestamp,json=blockTimestamp,proto3" json:"block_timestamp,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CTokenRequest) Reset()         { *m = CTokenRequest{} }
func (m *CTokenRequest) String() string { return proto.CompactTextString(m) }
func (*CTokenRequest) ProtoMessage()    {}
func (*CTokenRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_70252b6cac540031, []int{0}
}
func (m *CTokenRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CTokenRequest.Unmarshal(m, b)
}
func (m *CTokenRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CTokenRequest.Marshal(b, m, deterministic)
}
func (m *CTokenRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CTokenRequest.Merge(m, src)
}
func (m *CTokenRequest) XXX_Size() int {
	return xxx_messageInfo_CTokenRequest.Size(m)
}
func (m *CTokenRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CTokenRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CTokenRequest proto.InternalMessageInfo

func (m *CTokenRequest) GetAddresses() [][]byte {
	if m != nil {
		return m.Addresses
	}
	return nil
}

func (m *CTokenRequest) GetBlockNumber() uint32 {
	if m != nil {
		return m.BlockNumber
	}
	return 0
}

func (m *CTokenRequest) GetBlockTimestamp() uint32 {
	if m != nil {
		return m.BlockTimestamp
	}
	return 0
}

//*
// This includes a list of cTokens contextualized to the full market.
// <code>{
//  "cToken": [{
//    "borrow_rate": {"value": "0.051453109785093843"},
//    "cash": {"value": "514.078443"},
//    "collateral_factor": {"value": "0.80000000000000000"},
//    "exchange_rate": {"value": "0.020024242770802729"},
//    "interest_rate_model_address": "0x1a43bfd39b15dcf444e17ab408c4b5be32deb7f5",
//    "name": "Compound USD Coin",
//    "number_of_borrowers": 3,
//    "number_of_suppliers": 34,
//    "reserves": {"value": "0"},
//    "supply_rate": {"value": "0.013237112532748109"},
//    "symbol": "cUSDC",
//    "token_address": "0x5b281a6dda0b271e91ae35de655ad301c976edb1",
//    "total_borrows": {"value": "178.064546"},
//    "total_supply": {"value": "34565.25157651"},
//    "underlying_address": "0x4dbcdf9b62e891a7cec5a2568c3f4faf9e8abe2b",
//    "underlying_name": "USD Coin",
//    "underlying_price": {"value": "0.0041368287055953530000000000"},
//    "underlying_symbol":"USDC"
//   }],
//  "error": null,
//  "request": {
//    "addresses": ["0x5b281a6dda0b271e91ae35de655ad301c976edb1"],
//    "block_number": 4515576,
//    "block_timestamp": 0
//   }
// }</code>
type CToken struct {
	// The public Ethereum address of the cToken
	TokenAddress []byte `protobuf:"bytes,1,opt,name=token_address,json=tokenAddress,proto3" json:"token_address,omitempty"`
	// The number of cTokens in existence
	TotalSupply *Precise `protobuf:"bytes,2,opt,name=total_supply,json=totalSupply,proto3" json:"total_supply,omitempty"`
	// The amount of underlying tokens borrowed from the cToken
	TotalBorrows *Precise `protobuf:"bytes,4,opt,name=total_borrows,json=totalBorrows,proto3" json:"total_borrows,omitempty"`
	// The amount of underylying tokens held by reserves
	Reserves *Precise `protobuf:"bytes,5,opt,name=reserves,proto3" json:"reserves,omitempty"`
	// The current liquidity of the cToken
	Cash *Precise `protobuf:"bytes,6,opt,name=cash,proto3" json:"cash,omitempty"`
	// The cToken / underlying exchange rate. This rate increases over time
	// as supply interest accrues.
	ExchangeRate *Precise `protobuf:"bytes,7,opt,name=exchange_rate,json=exchangeRate,proto3" json:"exchange_rate,omitempty"`
	// The floating supply interest rate
	SupplyRate *Precise `protobuf:"bytes,8,opt,name=supply_rate,json=supplyRate,proto3" json:"supply_rate,omitempty"`
	// The floating borrow interest rate
	BorrowRate *Precise `protobuf:"bytes,9,opt,name=borrow_rate,json=borrowRate,proto3" json:"borrow_rate,omitempty"`
	// The amount of the value of the underlying token that will count as collateral.
	// eg. cEth with collataral factor 0.75 means 1 eth of supply allows 0.75 eth of
	// borrowing.
	CollateralFactor *Precise `protobuf:"bytes,10,opt,name=collateral_factor,json=collateralFactor,proto3" json:"collateral_factor,omitempty"`
	// The number of accounts holding this cToken
	NumberOfSuppliers uint32 `protobuf:"varint,11,opt,name=number_of_suppliers,json=numberOfSuppliers,proto3" json:"number_of_suppliers,omitempty"`
	// The number of accounts with oustanding borrows
	NumberOfBorrowers uint32 `protobuf:"varint,12,opt,name=number_of_borrowers,json=numberOfBorrowers,proto3" json:"number_of_borrowers,omitempty"`
	// The price of the underlying token in eth
	UnderlyingPrice *Precise `protobuf:"bytes,13,opt,name=underlying_price,json=underlyingPrice,proto3" json:"underlying_price,omitempty"`
	// The address of the underlying token
	UnderlyingAddress []byte `protobuf:"bytes,14,opt,name=underlying_address,json=underlyingAddress,proto3" json:"underlying_address,omitempty"`
	// The symbol of the ctoken
	Symbol string `protobuf:"bytes,15,opt,name=symbol,proto3" json:"symbol,omitempty"`
	// The name of the ctoken
	Name string `protobuf:"bytes,17,opt,name=name,proto3" json:"name,omitempty"`
	// The symbol of the underlying token
	UnderlyingSymbol string `protobuf:"bytes,18,opt,name=underlying_symbol,json=underlyingSymbol,proto3" json:"underlying_symbol,omitempty"`
	// The name of the underlying token
	UnderlyingName string `protobuf:"bytes,19,opt,name=underlying_name,json=underlyingName,proto3" json:"underlying_name,omitempty"`
	// The address of the interest rate model
	InterestRateModelAddress []byte   `protobuf:"bytes,20,opt,name=interest_rate_model_address,json=interestRateModelAddress,proto3" json:"interest_rate_model_address,omitempty"`
	XXX_NoUnkeyedLiteral     struct{} `json:"-"`
	XXX_unrecognized         []byte   `json:"-"`
	XXX_sizecache            int32    `json:"-"`
}

func (m *CToken) Reset()         { *m = CToken{} }
func (m *CToken) String() string { return proto.CompactTextString(m) }
func (*CToken) ProtoMessage()    {}
func (*CToken) Descriptor() ([]byte, []int) {
	return fileDescriptor_70252b6cac540031, []int{1}
}
func (m *CToken) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CToken.Unmarshal(m, b)
}
func (m *CToken) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CToken.Marshal(b, m, deterministic)
}
func (m *CToken) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CToken.Merge(m, src)
}
func (m *CToken) XXX_Size() int {
	return xxx_messageInfo_CToken.Size(m)
}
func (m *CToken) XXX_DiscardUnknown() {
	xxx_messageInfo_CToken.DiscardUnknown(m)
}

var xxx_messageInfo_CToken proto.InternalMessageInfo

func (m *CToken) GetTokenAddress() []byte {
	if m != nil {
		return m.TokenAddress
	}
	return nil
}

func (m *CToken) GetTotalSupply() *Precise {
	if m != nil {
		return m.TotalSupply
	}
	return nil
}

func (m *CToken) GetTotalBorrows() *Precise {
	if m != nil {
		return m.TotalBorrows
	}
	return nil
}

func (m *CToken) GetReserves() *Precise {
	if m != nil {
		return m.Reserves
	}
	return nil
}

func (m *CToken) GetCash() *Precise {
	if m != nil {
		return m.Cash
	}
	return nil
}

func (m *CToken) GetExchangeRate() *Precise {
	if m != nil {
		return m.ExchangeRate
	}
	return nil
}

func (m *CToken) GetSupplyRate() *Precise {
	if m != nil {
		return m.SupplyRate
	}
	return nil
}

func (m *CToken) GetBorrowRate() *Precise {
	if m != nil {
		return m.BorrowRate
	}
	return nil
}

func (m *CToken) GetCollateralFactor() *Precise {
	if m != nil {
		return m.CollateralFactor
	}
	return nil
}

func (m *CToken) GetNumberOfSuppliers() uint32 {
	if m != nil {
		return m.NumberOfSuppliers
	}
	return 0
}

func (m *CToken) GetNumberOfBorrowers() uint32 {
	if m != nil {
		return m.NumberOfBorrowers
	}
	return 0
}

func (m *CToken) GetUnderlyingPrice() *Precise {
	if m != nil {
		return m.UnderlyingPrice
	}
	return nil
}

func (m *CToken) GetUnderlyingAddress() []byte {
	if m != nil {
		return m.UnderlyingAddress
	}
	return nil
}

func (m *CToken) GetSymbol() string {
	if m != nil {
		return m.Symbol
	}
	return ""
}

func (m *CToken) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CToken) GetUnderlyingSymbol() string {
	if m != nil {
		return m.UnderlyingSymbol
	}
	return ""
}

func (m *CToken) GetUnderlyingName() string {
	if m != nil {
		return m.UnderlyingName
	}
	return ""
}

func (m *CToken) GetInterestRateModelAddress() []byte {
	if m != nil {
		return m.InterestRateModelAddress
	}
	return nil
}

//
// The cToken API returns an overall picture of cTokens matching the filter.
type CTokenResponse struct {
	// If set and non-zero, indicates an error returning data.
	// <pre>NO_ERROR = 0
	// INTERNAL_ERROR = 1
	Error *Error `protobuf:"bytes,1,opt,name=error,proto3" json:"error,omitempty"`
	// The request parameters are echoed in the response.
	Request *CTokenRequest `protobuf:"bytes,2,opt,name=request,proto3" json:"request,omitempty"`
	// The list of cToken (see <ref>CToken</ref> below) matching the requested filter.
	CToken               []*CToken `protobuf:"bytes,3,rep,name=cToken,proto3" json:"cToken,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *CTokenResponse) Reset()         { *m = CTokenResponse{} }
func (m *CTokenResponse) String() string { return proto.CompactTextString(m) }
func (*CTokenResponse) ProtoMessage()    {}
func (*CTokenResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_70252b6cac540031, []int{2}
}
func (m *CTokenResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CTokenResponse.Unmarshal(m, b)
}
func (m *CTokenResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CTokenResponse.Marshal(b, m, deterministic)
}
func (m *CTokenResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CTokenResponse.Merge(m, src)
}
func (m *CTokenResponse) XXX_Size() int {
	return xxx_messageInfo_CTokenResponse.Size(m)
}
func (m *CTokenResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CTokenResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CTokenResponse proto.InternalMessageInfo

func (m *CTokenResponse) GetError() *Error {
	if m != nil {
		return m.Error
	}
	return nil
}

func (m *CTokenResponse) GetRequest() *CTokenRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

func (m *CTokenResponse) GetCToken() []*CToken {
	if m != nil {
		return m.CToken
	}
	return nil
}

func init() {
	proto.RegisterEnum("API.Presidio.CTokenResponseErrorCodes", CTokenResponseErrorCodes_name, CTokenResponseErrorCodes_value)
	proto.RegisterType((*CTokenRequest)(nil), "API.Presidio.CTokenRequest")
	proto.RegisterType((*CToken)(nil), "API.Presidio.CToken")
	proto.RegisterType((*CTokenResponse)(nil), "API.Presidio.CTokenResponse")
}

func init() { proto.RegisterFile("ctoken.proto", fileDescriptor_70252b6cac540031) }

var fileDescriptor_70252b6cac540031 = []byte{
	// 663 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x94, 0xc1, 0x6e, 0xd3, 0x4c,
	0x10, 0xc7, 0x3f, 0x37, 0x6d, 0xd2, 0x8c, 0x9d, 0xa4, 0x99, 0xf6, 0x43, 0xab, 0xb6, 0x87, 0x10,
	0x0e, 0x4d, 0x05, 0x04, 0x11, 0x04, 0x42, 0x48, 0x48, 0xb4, 0x55, 0x91, 0x2a, 0x41, 0x5a, 0x39,
	0xb9, 0x70, 0xb2, 0x1c, 0x67, 0xda, 0x5a, 0xb5, 0xbd, 0x66, 0x77, 0x53, 0xc8, 0x15, 0x1e, 0x81,
	0x17, 0xe2, 0x11, 0x90, 0x78, 0x05, 0x1e, 0x04, 0x79, 0xd7, 0x6e, 0x12, 0xa9, 0xf2, 0x89, 0x5b,
	0xf2, 0x9f, 0xdf, 0x7f, 0x66, 0x76, 0x77, 0x3c, 0xe0, 0x04, 0x8a, 0xdf, 0x50, 0xd2, 0x4f, 0x05,
	0x57, 0x1c, 0x9d, 0xa3, 0x8b, 0xb3, 0xfe, 0x85, 0x20, 0x19, 0x4e, 0x43, 0xbe, 0xdb, 0xf6, 0x93,
	0x84, 0x2b, 0x5f, 0x85, 0x3c, 0x91, 0x06, 0xd8, 0x75, 0x02, 0x1e, 0xc7, 0x3c, 0xc7, 0xbb, 0x73,
	0x68, 0x9c, 0x8c, 0x33, 0xbb, 0x4b, 0x9f, 0x67, 0x24, 0x15, 0xee, 0x43, 0xdd, 0x9f, 0x4e, 0x05,
	0x49, 0x49, 0x92, 0x59, 0x9d, 0x4a, 0xcf, 0x71, 0x17, 0x02, 0x3e, 0x04, 0x67, 0x12, 0xf1, 0xe0,
	0xc6, 0x4b, 0x66, 0xf1, 0x84, 0x04, 0x5b, 0xeb, 0x58, 0xbd, 0x86, 0x6b, 0x6b, 0x6d, 0xa8, 0x25,
	0x3c, 0x80, 0x96, 0x41, 0x54, 0x18, 0x93, 0x54, 0x7e, 0x9c, 0xb2, 0x8a, 0xa6, 0x9a, 0x5a, 0x1e,
	0x17, 0x6a, 0xf7, 0x7b, 0x0d, 0xaa, 0xa6, 0x36, 0x3e, 0x82, 0x86, 0x3e, 0x83, 0x97, 0x57, 0x62,
	0x56, 0xc7, 0xea, 0x39, 0xae, 0xa3, 0xc5, 0x23, 0xa3, 0xe1, 0x6b, 0x70, 0x14, 0x57, 0x7e, 0xe4,
	0xc9, 0x59, 0x9a, 0x46, 0x73, 0x5d, 0xdb, 0x1e, 0xfc, 0xdf, 0x5f, 0x3e, 0x70, 0xf6, 0x23, 0x08,
	0x25, 0xb9, 0xb6, 0x46, 0x47, 0x9a, 0xc4, 0x37, 0x59, 0xfa, 0xcc, 0x39, 0xe1, 0x42, 0xf0, 0x2f,
	0x92, 0xad, 0x97, 0x59, 0x4d, 0x95, 0x63, 0x83, 0xe2, 0x73, 0xd8, 0x14, 0x24, 0x49, 0xdc, 0x92,
	0x64, 0x1b, 0x65, 0xb6, 0x3b, 0x0c, 0x0f, 0x61, 0x3d, 0xf0, 0xe5, 0x35, 0xab, 0x96, 0xe1, 0x1a,
	0xc9, 0x3a, 0xa3, 0xaf, 0xc1, 0xb5, 0x9f, 0x5c, 0x91, 0x27, 0x7c, 0x45, 0xac, 0x56, 0xda, 0x59,
	0xc1, 0xba, 0xbe, 0x22, 0x7c, 0x05, 0xb6, 0xb9, 0x09, 0xe3, 0xdc, 0x2c, 0x73, 0x82, 0x21, 0x0b,
	0x9f, 0xb9, 0x07, 0xe3, 0xab, 0x97, 0xfa, 0x0c, 0xa9, 0x7d, 0xc7, 0xd0, 0x0e, 0x78, 0x14, 0xf9,
	0x8a, 0x84, 0x1f, 0x79, 0x97, 0x7e, 0xa0, 0xb8, 0x60, 0x50, 0xe6, 0xde, 0x5a, 0xf0, 0xef, 0x35,
	0x8e, 0x7d, 0xd8, 0x36, 0x93, 0xe3, 0xf1, 0x4b, 0xf3, 0x8e, 0x21, 0x09, 0xc9, 0x6c, 0x3d, 0x20,
	0x6d, 0x13, 0x3a, 0xbf, 0x1c, 0x15, 0x81, 0x55, 0xde, 0xf4, 0x92, 0xf1, 0xce, 0x2a, 0x7f, 0x5c,
	0x04, 0xf0, 0x1d, 0x6c, 0xcd, 0x92, 0x29, 0x89, 0x68, 0x1e, 0x26, 0x57, 0x5e, 0x2a, 0xc2, 0x80,
	0x58, 0xa3, 0xac, 0xc5, 0xd6, 0x02, 0xbf, 0xc8, 0x68, 0x7c, 0x0a, 0xb8, 0x94, 0xa1, 0x98, 0xc7,
	0xa6, 0x9e, 0xc7, 0xf6, 0x22, 0x52, 0x0c, 0xe5, 0x03, 0xa8, 0xca, 0x79, 0x3c, 0xe1, 0x11, 0x6b,
	0x75, 0xac, 0x5e, 0xdd, 0xcd, 0xff, 0x21, 0xc2, 0x7a, 0xe2, 0xc7, 0xc4, 0xda, 0x5a, 0xd5, 0xbf,
	0xf1, 0x31, 0x2c, 0x25, 0xf0, 0x72, 0x1b, 0x6a, 0x60, 0xa9, 0xeb, 0x91, 0x49, 0x70, 0x00, 0x4b,
	0xad, 0x79, 0x3a, 0xd7, 0xb6, 0x46, 0x9b, 0x0b, 0x79, 0x98, 0x65, 0x7d, 0x0b, 0x7b, 0x61, 0xa2,
	0x48, 0x90, 0x54, 0xfa, 0x41, 0xbd, 0x98, 0x4f, 0x29, 0xba, 0xeb, 0x7c, 0x47, 0x77, 0xce, 0x0a,
	0x24, 0x7b, 0xc9, 0x8f, 0x19, 0x90, 0x1f, 0xa0, 0xfb, 0xcb, 0x82, 0x66, 0xb1, 0x01, 0x64, 0xca,
	0x13, 0x49, 0x78, 0x08, 0x1b, 0x24, 0x04, 0x17, 0xfa, 0x2b, 0xb4, 0x07, 0xdb, 0xab, 0x37, 0x77,
	0x9a, 0x85, 0x5c, 0x43, 0xe0, 0x4b, 0xa8, 0x09, 0xb3, 0x38, 0xf2, 0xcf, 0x71, 0x6f, 0x15, 0x5e,
	0xd9, 0x2d, 0x6e, 0xc1, 0xe2, 0x13, 0xa8, 0x06, 0x3a, 0xc2, 0x2a, 0x9d, 0x4a, 0xcf, 0x1e, 0xec,
	0xdc, 0xeb, 0xca, 0x99, 0x6e, 0x1f, 0x40, 0x57, 0x3b, 0xe1, 0x53, 0x92, 0xe8, 0xc0, 0xe6, 0xf0,
	0xdc, 0x3b, 0x75, 0xdd, 0x73, 0x77, 0xeb, 0x3f, 0x44, 0x68, 0x9e, 0x0d, 0xc7, 0xa7, 0xee, 0xf0,
	0xe8, 0x43, 0xae, 0x59, 0x83, 0x9f, 0x56, 0xb1, 0xd4, 0x46, 0x24, 0x6e, 0xb3, 0x47, 0x1d, 0x43,
	0xd5, 0x2c, 0x49, 0x2c, 0xeb, 0x6f, 0x77, 0xff, 0xfe, 0xa0, 0xb9, 0x96, 0x6e, 0xeb, 0xdb, 0xef,
	0x3f, 0x3f, 0xd6, 0xea, 0x58, 0x7b, 0x96, 0xe7, 0xfa, 0x04, 0x76, 0xca, 0xa5, 0xf2, 0xfe, 0x59,
	0xea, 0x6e, 0x91, 0x7a, 0x52, 0xd5, 0xdb, 0xf9, 0xc5, 0xdf, 0x00, 0x00, 0x00, 0xff, 0xff, 0x5a,
	0xb4, 0x90, 0xa4, 0xdc, 0x05, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// CTokenServiceClient is the client API for CTokenService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type CTokenServiceClient interface {
	Ctoken(ctx context.Context, in *CTokenRequest, opts ...grpc.CallOption) (*CTokenResponse, error)
	PostCtoken(ctx context.Context, in *CTokenRequest, opts ...grpc.CallOption) (*CTokenResponse, error)
}

type cTokenServiceClient struct {
	cc *grpc.ClientConn
}

func NewCTokenServiceClient(cc *grpc.ClientConn) CTokenServiceClient {
	return &cTokenServiceClient{cc}
}

func (c *cTokenServiceClient) Ctoken(ctx context.Context, in *CTokenRequest, opts ...grpc.CallOption) (*CTokenResponse, error) {
	out := new(CTokenResponse)
	err := c.cc.Invoke(ctx, "/API.Presidio.CTokenService/ctoken", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cTokenServiceClient) PostCtoken(ctx context.Context, in *CTokenRequest, opts ...grpc.CallOption) (*CTokenResponse, error) {
	out := new(CTokenResponse)
	err := c.cc.Invoke(ctx, "/API.Presidio.CTokenService/post_ctoken", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CTokenServiceServer is the server API for CTokenService service.
type CTokenServiceServer interface {
	Ctoken(context.Context, *CTokenRequest) (*CTokenResponse, error)
	PostCtoken(context.Context, *CTokenRequest) (*CTokenResponse, error)
}

func RegisterCTokenServiceServer(s *grpc.Server, srv CTokenServiceServer) {
	s.RegisterService(&_CTokenService_serviceDesc, srv)
}

func _CTokenService_Ctoken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CTokenServiceServer).Ctoken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/API.Presidio.CTokenService/Ctoken",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CTokenServiceServer).Ctoken(ctx, req.(*CTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CTokenService_PostCtoken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CTokenServiceServer).PostCtoken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/API.Presidio.CTokenService/PostCtoken",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CTokenServiceServer).PostCtoken(ctx, req.(*CTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _CTokenService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "API.Presidio.CTokenService",
	HandlerType: (*CTokenServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ctoken",
			Handler:    _CTokenService_Ctoken_Handler,
		},
		{
			MethodName: "post_ctoken",
			Handler:    _CTokenService_PostCtoken_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "ctoken.proto",
}
